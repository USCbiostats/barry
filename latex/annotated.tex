\section{Class List}
Here are the classes, structs, unions and interfaces with brief descriptions\+:\begin{DoxyCompactList}
\item\contentsline{section}{\hyperlink{class_b_array}{B\+Array$<$ Cell\+\_\+\+Type, Data\+\_\+\+Type $>$} \\*Baseline class for binary arrays }{\pageref{class_b_array}}{}
\item\contentsline{section}{\hyperlink{classbarry_1_1_b_array}{barry\+::\+B\+Array$<$ Cell\+\_\+\+Type, Data\+\_\+\+Type $>$} }{\pageref{classbarry_1_1_b_array}}{}
\item\contentsline{section}{\hyperlink{class_b_array_cell}{B\+Array\+Cell$<$ Cell\+\_\+\+Type, Data\+\_\+\+Type $>$} }{\pageref{class_b_array_cell}}{}
\item\contentsline{section}{\hyperlink{classbarry_1_1_cell}{barry\+::\+Cell$<$ Cell\+\_\+\+Type $>$} \\*\hyperlink{classbarry_1_1_entries}{Entries} in \hyperlink{classbarry_1_1_b_array}{B\+Array}. For now, it only has two members\+: }{\pageref{classbarry_1_1_cell}}{}
\item\contentsline{section}{\hyperlink{class_cell}{Cell$<$ Cell\+\_\+\+Type $>$} \\*\hyperlink{class_entries}{Entries} in \hyperlink{class_b_array}{B\+Array}. For now, it only has two members\+: }{\pageref{class_cell}}{}
\item\contentsline{section}{\hyperlink{class_cell_seq}{Cell\+Seq$<$ Array\+\_\+\+Type, Data\+\_\+\+Type $>$} \\*Sequence of cells indices }{\pageref{class_cell_seq}}{}
\item\contentsline{section}{\hyperlink{classbarry_1_1_cell_seq}{barry\+::\+Cell\+Seq$<$ Array\+\_\+\+Type, Data\+\_\+\+Type $>$} \\*Sequence of cells indices }{\pageref{classbarry_1_1_cell_seq}}{}
\item\contentsline{section}{\hyperlink{class_const_b_array_row_iter}{Const\+B\+Array\+Row\+Iter$<$ Cell\+\_\+\+Type, Data\+\_\+\+Type $>$} }{\pageref{class_const_b_array_row_iter}}{}
\item\contentsline{section}{\hyperlink{classbarry_1_1_counter}{barry\+::\+Counter$<$ Array\+\_\+\+Type, Data\+\_\+\+Type $>$} \\*A counter function based on change statistics }{\pageref{classbarry_1_1_counter}}{}
\item\contentsline{section}{\hyperlink{class_counter}{Counter$<$ Array\+\_\+\+Type, Data\+\_\+\+Type $>$} \\*A counter function based on change statistics }{\pageref{class_counter}}{}
\item\contentsline{section}{\hyperlink{classbarry_1_1_counters}{barry\+::\+Counters$<$ Array\+\_\+\+Type, Data\+\_\+\+Type $>$} \\*Vector of counters }{\pageref{classbarry_1_1_counters}}{}
\item\contentsline{section}{\hyperlink{class_counters}{Counters$<$ Array\+\_\+\+Type, Data\+\_\+\+Type $>$} \\*Vector of counters }{\pageref{class_counters}}{}
\item\contentsline{section}{\hyperlink{class_entries}{Entries$<$ Cell\+\_\+\+Type $>$} \\*A wrapper class to store {\ttfamily source}, {\ttfamily target}, {\ttfamily val} from a {\ttfamily \hyperlink{class_b_array}{B\+Array}} object }{\pageref{class_entries}}{}
\item\contentsline{section}{\hyperlink{classbarry_1_1_entries}{barry\+::\+Entries$<$ Cell\+\_\+\+Type $>$} \\*A wrapper class to store {\ttfamily source}, {\ttfamily target}, {\ttfamily val} from a {\ttfamily \hyperlink{classbarry_1_1_b_array}{B\+Array}} object }{\pageref{classbarry_1_1_entries}}{}
\item\contentsline{section}{\hyperlink{class_freq_table}{Freq\+Table$<$ T $>$} \\*Database of statistics }{\pageref{class_freq_table}}{}
\item\contentsline{section}{\hyperlink{classbarry_1_1_freq_table}{barry\+::\+Freq\+Table$<$ T $>$} \\*Database of statistics }{\pageref{classbarry_1_1_freq_table}}{}
\item\contentsline{section}{\hyperlink{classbarry_1_1_model}{barry\+::\+Model$<$ Array\+\_\+\+Type, Data\+\_\+\+Counter\+\_\+\+Type, Data\+\_\+\+Rule\+\_\+\+Type $>$} \\*General framework for discrete exponential models. This class allows generating discrete exponential models in the form of a linear exponential model\+: \[ \frac{ \exp{\left(\theta^{\mbox{t}}c(A)\right)} }{ \sum_{A'\in \mathcal{A}}\exp{\left(\theta^{\mbox{t}}c(A')\right)} } \] }{\pageref{classbarry_1_1_model}}{}
\item\contentsline{section}{\hyperlink{class_model}{Model$<$ Array\+\_\+\+Type, Data\+\_\+\+Counter\+\_\+\+Type, Data\+\_\+\+Rule\+\_\+\+Type $>$} \\*General framework for discrete exponential models. This class allows generating discrete exponential models in the form of a linear exponential model\+: \[ \frac{ \exp{\left(\theta^{\mbox{t}}c(A)\right)} }{ \sum_{A'\in \mathcal{A}}\exp{\left(\theta^{\mbox{t}}c(A')\right)} } \] }{\pageref{class_model}}{}
\item\contentsline{section}{\hyperlink{classbarry_1_1counters_1_1network_1_1_net_counter_data}{barry\+::counters\+::network\+::\+Net\+Counter\+Data} \\*Data class used to store arbitrary uint or double vectors }{\pageref{classbarry_1_1counters_1_1network_1_1_net_counter_data}}{}
\item\contentsline{section}{\hyperlink{class_net_counter_data}{Net\+Counter\+Data} \\*Data class used to store arbitrary uint or double vectors }{\pageref{class_net_counter_data}}{}
\item\contentsline{section}{\hyperlink{classbarry_1_1counters_1_1network_1_1_network_data}{barry\+::counters\+::network\+::\+Network\+Data} \\*Data class for Networks }{\pageref{classbarry_1_1counters_1_1network_1_1_network_data}}{}
\item\contentsline{section}{\hyperlink{class_network_data}{Network\+Data} \\*Data class for Networks }{\pageref{class_network_data}}{}
\item\contentsline{section}{\hyperlink{class_node_data}{Node\+Data} \\*Data definition for the {\ttfamily Phylo\+Array} class }{\pageref{class_node_data}}{}
\item\contentsline{section}{\hyperlink{classbarry_1_1counters_1_1phylo_1_1_node_data}{barry\+::counters\+::phylo\+::\+Node\+Data} \\*Data definition for the {\ttfamily Phylo\+Array} class }{\pageref{classbarry_1_1counters_1_1phylo_1_1_node_data}}{}
\item\contentsline{section}{\hyperlink{classbarry_1_1_power_set}{barry\+::\+Power\+Set$<$ Array\+\_\+\+Type, Data\+\_\+\+Rule\+\_\+\+Type $>$} }{\pageref{classbarry_1_1_power_set}}{}
\item\contentsline{section}{\hyperlink{class_power_set}{Power\+Set$<$ Array\+\_\+\+Type, Data\+\_\+\+Rule\+\_\+\+Type $>$} }{\pageref{class_power_set}}{}
\item\contentsline{section}{\hyperlink{classbarry_1_1_rule}{barry\+::\+Rule$<$ Array\+\_\+\+Type, Data\+\_\+\+Type $>$} \\*\hyperlink{classbarry_1_1_rule}{Rule} for determining if a cell should be included in a sequence }{\pageref{classbarry_1_1_rule}}{}
\item\contentsline{section}{\hyperlink{class_rule}{Rule$<$ Array\+\_\+\+Type, Data\+\_\+\+Type $>$} \\*\hyperlink{class_rule}{Rule} for determining if a cell should be included in a sequence }{\pageref{class_rule}}{}
\item\contentsline{section}{\hyperlink{classbarry_1_1_rules}{barry\+::\+Rules$<$ Array\+\_\+\+Type, Data\+\_\+\+Type $>$} \\*Vector of objects of class \hyperlink{classbarry_1_1_rule}{Rule} }{\pageref{classbarry_1_1_rules}}{}
\item\contentsline{section}{\hyperlink{class_rules}{Rules$<$ Array\+\_\+\+Type, Data\+\_\+\+Type $>$} \\*Vector of objects of class \hyperlink{class_rule}{Rule} }{\pageref{class_rules}}{}
\item\contentsline{section}{\hyperlink{class_stats_counter}{Stats\+Counter$<$ Array\+\_\+\+Type, Data\+\_\+\+Type $>$} \\*Count stats for a single Array }{\pageref{class_stats_counter}}{}
\item\contentsline{section}{\hyperlink{classbarry_1_1_stats_counter}{barry\+::\+Stats\+Counter$<$ Array\+\_\+\+Type, Data\+\_\+\+Type $>$} \\*Count stats for a single Array }{\pageref{classbarry_1_1_stats_counter}}{}
\item\contentsline{section}{\hyperlink{classbarry_1_1_support}{barry\+::\+Support$<$ Array\+\_\+\+Type, Data\+\_\+\+Counter\+\_\+\+Type, Data\+\_\+\+Rule\+\_\+\+Type $>$} \\*Compute the support of sufficient statistics }{\pageref{classbarry_1_1_support}}{}
\item\contentsline{section}{\hyperlink{class_support}{Support$<$ Array\+\_\+\+Type, Data\+\_\+\+Counter\+\_\+\+Type, Data\+\_\+\+Rule\+\_\+\+Type $>$} \\*Compute the support of sufficient statistics }{\pageref{class_support}}{}
\item\contentsline{section}{\hyperlink{structbarry_1_1vec_hasher}{barry\+::vec\+Hasher$<$ T $>$} }{\pageref{structbarry_1_1vec_hasher}}{}
\item\contentsline{section}{\hyperlink{structvec_hasher}{vec\+Hasher$<$ T $>$} }{\pageref{structvec_hasher}}{}
\end{DoxyCompactList}

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Binary Arrays: README</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Binary Arrays
   &#160;<span id="projectnumber">0.0-0</span>
   </div>
   <div id="projectbrief">Full enumeration of sample space for binary arrays</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">README </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This repository contains a C++ template library that essentially counts sufficient statistics on binary arrays. The idea of the library is that this can be used together to build exponential family models as those in Exponential Random Graph Models (ERGMs), but as a generalization that also deals with non square arrays.</p>
<h1>Design considerations</h1>
<h2>Data structures</h2>
<p>For start, the main class object should hold the following:</p>
<ul>
<li><b>The array structure</b> Right now, we are thinking on dealing with an <code>std::unordered_map</code> type of structure since search/addition/removel operations have constant average time.</li>
<li><b>Pointer to undefined structure</b> Besides of the graph itself, the data may be acompained by other datasets, for example, in the case of genetic annotation we may have the current state of some genes, i.e., a binary vector.</li>
<li><p class="startli"><b>Structural constrains</b> Having arrays specifying the blocked spaces of the array. This, in principle, could affect all operations related to modifying the array, e.g. if the pair <code>(i, j)</code> is blocked, then no addition/deletion can be done on that respect.</p>
<p class="startli">The structural constrains may be better reflected as a counterpart: free blocks. This way, any algorithm that needs to iterate through cells that can be changed can use its counter part.</p>
<p class="startli">Enumeration of both sets would have in total $n  m$ unordered pairs. One problem of this is the fact that this type of data structure is unefficient as it can grow too fast. Yet, the whole idea of this C++ library is to be able to fully enumerate support of arrays, so problems that need to deal with larger datasets may not be suitable for this approach.</p>
</li>
</ul>
<h2>Algorithms to implement</h2>
<ul>
<li><p class="startli"><b>Counters</b> Users should be able to define counters using change statistics. From the ERGM literature, we know that change statistics can be a very efficient way of counting when we have a Markov process. In our case, since we will be doing exhaustive ennumeration, a good an efficient way of counting statistics is counting as we add/remove zeros.</p>
<p class="startli">Counters should have the following implementation:</p>
</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> counter_[name](<span class="keyword">const</span> Array &amp; x, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> row, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> col) {</div><div class="line">  <span class="comment">// Visit neighbors</span></div><div class="line">  Array::local_iterator iter(x, row, col);</div><div class="line">  <span class="keywordtype">double</span> counts = 0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> i = iter.begin(); i != iter.end(); ++i) {</div><div class="line">    ...[<span class="keywordflow">do</span> your thing]...</div><div class="line">    counts += ...</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> counts;</div><div class="line">}</div></div><!-- fragment --><ul>
<li><p class="startli"><b>Constrained Exhaust enumeration</b> Exhaust enumeration can be done using recursive algorithms activating and deactivating cells in the array. One nice feature would be to allow users to specify constrained, essentially blocked, cells in the array. This would go together with the counters.</p>
<p class="startli">The constrains can just be <code>std::unordered_map</code> objects in which the coordinates of the cells that need to be blocked are specified. Some standard constrains can be:</p><ul>
<li>Blocks (ranges).</li>
<li>Symmetry (in the case of square, undirected graphs).</li>
</ul>
<p class="startli">Furthermore, we should, at least in principle, allow the user to speficy default values for the blocked cells (0/1).</p>
</li>
<li><b>Array changes</b> Addition and deletion of 0/1 states. If we use <code>std::unordered_map</code> this should be straight forward. Perhaps just making an alias or binary operator, e.g.</li>
</ul>
<div class="fragment"><div class="line">X += (i, j);</div><div class="line">X.add(i, j);</div><div class="line">X.rm(i, j);</div></div><!-- fragment --><ul>
<li><p class="startli"><b>Markov Chains</b> This would be nice to have, but not necesary for now. The idea is to have various types of algorithms to implement transitions to new states, for example</p><ul>
<li>Randomly adding/removing new pairs.</li>
<li>Unconstrained endpoints-switching/swap.</li>
<li>Constrained endpoints-swap.</li>
</ul>
<p class="startli">The constrained component can be related to the graph constrains specified part of the countner.</p>
</li>
<li><p class="startli"><b>Estimate support size</b> Do this conditioning on the constrains. This should be rather straight forward. The support of the set should be defined by</p>
<p class="startli">$$ 2^{(n m - |blocked|)} $$</p>
<p class="startli">Where $blocked$ is the set of blocked cells. </p>
</li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
